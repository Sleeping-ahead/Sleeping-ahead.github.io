<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="摘要：平面相交细分；候选面集简化；面片置信度计算；候选平面集。">
<meta property="og:type" content="article">
<meta property="og:title" content="点云三维重建 PolyFit算法解析与改进（六）">
<meta property="og:url" content="http://example.com/2025/01/21/PolyFit06/index.html">
<meta property="og:site_name" content="前排瞌睡杂物堆">
<meta property="og:description" content="摘要：平面相交细分；候选面集简化；面片置信度计算；候选平面集。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2025/01/21/PolyFit06/%E5%80%99%E9%80%89%E5%B9%B3%E9%9D%A2%E7%9B%B8%E4%BA%A4%E7%BB%86%E5%88%86.png">
<meta property="og:image" content="http://example.com/2025/01/21/PolyFit06/%E5%80%99%E9%80%89%E9%9D%A2%E9%9B%86%E7%AE%80%E5%8C%96.png">
<meta property="og:image" content="http://example.com/2025/01/21/PolyFit06/%E8%83%BD%E9%87%8F%E5%87%BD%E6%95%B0%E6%9E%84%E6%88%90.png">
<meta property="og:image" content="http://example.com/2025/01/21/PolyFit06/%E5%80%99%E9%80%89%E9%9D%A2%E6%8B%93%E6%89%91%E5%85%B3%E7%B3%BB.png">
<meta property="og:image" content="http://example.com/2025/01/21/PolyFit06/%E5%8C%BA%E5%9F%9F%E6%9C%9D%E5%90%91%E9%9D%A2%E7%89%872%E5%80%99%E9%80%89%E9%9D%A2%E9%9B%86.png">
<meta property="article:published_time" content="2025-01-21T14:25:48.000Z">
<meta property="article:modified_time" content="2025-03-29T15:30:56.159Z">
<meta property="article:author" content="Sleeping-Ahead">
<meta property="article:tag" content="C++">
<meta property="article:tag" content="CGAL">
<meta property="article:tag" content="PolyFit">
<meta property="article:tag" content="面片结构处理">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2025/01/21/PolyFit06/%E5%80%99%E9%80%89%E5%B9%B3%E9%9D%A2%E7%9B%B8%E4%BA%A4%E7%BB%86%E5%88%86.png">

<link rel="canonical" href="http://example.com/2025/01/21/PolyFit06/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>点云三维重建 PolyFit算法解析与改进（六） | 前排瞌睡杂物堆</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">前排瞌睡杂物堆</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">LKH 求存，探路，躬行，旁通，振兴，延续。<br>第二阶段，启动！</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/01/21/PolyFit06/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Sleeping-Ahead">
      <meta itemprop="description" content="主要用途是技术/算法的记录博客哒！<br>偶尔摘抄点杂七杂八的随想~~<br>嘻嘻ԅ(¯﹃¯ԅ)">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="前排瞌睡杂物堆">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          点云三维重建 PolyFit算法解析与改进（六）
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-01-21 22:25:48" itemprop="dateCreated datePublished" datetime="2025-01-21T22:25:48+08:00">2025-01-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-03-29 23:30:56" itemprop="dateModified" datetime="2025-03-29T23:30:56+08:00">2025-03-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%82%B9%E4%BA%91%E4%B8%89%E7%BB%B4%E9%87%8D%E5%BB%BA/" itemprop="url" rel="index"><span itemprop="name">点云三维重建</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>33k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1:01</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>摘要：<br>平面相交细分；候选面集简化；面片置信度计算；候选平面集。</p>
<span id="more"></span>

<p>中场休息结束！！ok，继续分析PolyFit中构造面片的代码。<br>上一章节，建筑物点云被处理为表示各个区域朝向的面片数据，存储在多边形网络mesh_candidate中。尽管这些提取到的面对象能初步表示建筑物的几何特性，但显然它们之间是孤立的，缺少相交、邻接、连通等拓扑关系，且明显有冗余的部分区域需要被剪除。那么，如上一节末尾所述，接下来便是对网络中的各个面片做细化、去冗处理。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//4、候选平面相交细分</span></span><br><span class="line"><span class="comment">//2023.11.23 在包围盒平面与细分的平面上，对面的属性增加分区属性</span></span><br><span class="line"><span class="built_in">SegMeshCandidate</span>(mesh_candidate);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//5.1、候选面集简化处理</span></span><br><span class="line"><span class="comment">//SimpleMeshCandidate(mesh_candidate);//激进简化，有时重建效果巨差</span></span><br><span class="line"><span class="built_in">SimpleMeshCandidate_V2</span>(mesh_candidate);<span class="comment">//保守简化</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//5.2、附加顶面偏好属性</span></span><br><span class="line"><span class="built_in">AddMeshProperty</span>(mesh_candidate);</span><br><span class="line"></span><br><span class="line"><span class="comment">//6、计算候选面的置信度</span></span><br><span class="line"><span class="comment">//该操作为 mesh_candidate 添加了3个属性映射,用于后续的MIP处理：</span></span><br><span class="line"><span class="comment">//平面的支撑点数	f:num_supporting_points</span></span><br><span class="line"><span class="comment">//平面面积			f:face_area</span></span><br><span class="line"><span class="comment">//覆盖面积			f:covered_area</span></span><br><span class="line">CGAL::internal::Candidate_confidences&lt;Kernel&gt; conf;</span><br><span class="line">conf.<span class="built_in">compute</span>(cloud_plane, mesh_candidate);</span><br></pre></td></tr></table></figure>

<h2 id="候选平面相交细分"><a href="#候选平面相交细分" class="headerlink" title="候选平面相交细分"></a>候选平面相交细分</h2><p>现在的mesh_candidate中存有若干块表示建筑特征区域朝向的大块面片，若直接以聚类区域边界划分面片，由于点云数据的噪声及区域表面的不平滑特性（可能表征为多个不同方向的平面），该过程往往会切割出一些非预期的平面；且点云覆盖度若较差，容易在模型中产生空洞或不连续的区域，从而降低重建模型的几何精度和视觉质量。而按照这种思路切分出的各区域面，还需要进行面片间的复杂拓扑关系处理后才能整合成模型表面，如相交面的边界融合&#x2F;平滑、形状规则化<sup>[20]</sup>、同名相交点的精度控制。<br>PolyFit算法中的平面细化采用的是暴力穷举的思路。不同于上述那种先取轮廓再不断优化边界的策略，它是先以平面两两相交的方式将mesh_candidate的大块面切成超多细碎面，从而显式表达了聚类区域的所有相交情况；再按照各个面的能量函数值删除、保留面片，最终将隐含的模型表面给筛选出来。这通操作避免了对模型相交边界的优化问题，将模型重建方法从面片结构和面片间的拓扑关系的优化问题，转为从潜在的多边形面集内筛选出组成模型的最优面集。当然缺点也是有的：两两相交会产生大量冗余面，会导致在计算能量项那块出现计算瓶颈。<br>这种取切面策略的缺陷后面再详述，先聚焦回平面相交细分，它的代码在HypothesisPlaneProcess::SegMeshCandidate()函数内，过程包括计算潜在的三重交点、确定相交面、平面分割这三个步骤。</p>
<h3 id="计算三重交点"><a href="#计算三重交点" class="headerlink" title="计算三重交点"></a>计算三重交点</h3><p>按顺序取mesh_candidate中的三个平面，使用CGAL::intersection计算它们三个间是否交于一点，有则将点存入_triplet_intersections。老实说这一步放在这里就计算有点太早了，因为这些点的信息很后面才用到，得到了网络结构重建的ReconstructProcess::GetAdjacency函数中才会调取它们来计算面的邻接情况。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1、预先计算平面三元组（依次选取相邻顺序的三个平面）所有潜在的三重交集点（三平面交于一点的点集）</span></span><br><span class="line">std::vector&lt;<span class="type">const</span> Kernel::Point_3*&gt; intersecting_points_;<span class="comment">//容器_三重交点//8.29_似乎仅做统计，后续用不上</span></span><br><span class="line">_triplet_intersections.<span class="built_in">clear</span>();</span><br><span class="line"><span class="keyword">if</span> (_supporting_planes.<span class="built_in">size</span>() &lt; <span class="number">4</span>)</span><br><span class="line">	<span class="keyword">return</span>;<span class="comment">//少于4个平面将无法构成闭合网络，退出本函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (std::<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; _supporting_planes.<span class="built_in">size</span>(); ++i)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">const</span> Kernel::Plane_3* plane1 = _supporting_planes[i];</span><br><span class="line">	<span class="keyword">for</span> (std::<span class="type">size_t</span> j = i + <span class="number">1</span>; j &lt; _supporting_planes.<span class="built_in">size</span>(); ++j)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">const</span> Kernel::Plane_3* plane2 = _supporting_planes[j];</span><br><span class="line">		<span class="keyword">for</span> (std::<span class="type">size_t</span> k = j + <span class="number">1</span>; k &lt; _supporting_planes.<span class="built_in">size</span>(); ++k)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">const</span> Kernel::Plane_3* plane3 = _supporting_planes[k];</span><br><span class="line">			<span class="built_in">CGAL_assertion</span>(plane1 &lt; plane2 &amp;&amp; plane2 &lt; plane3);<span class="comment">//断言_三个平面的指针是否按升序排列的</span></span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (plane1 == plane2 || plane1 == plane3 || plane2 == plane3)</span><br><span class="line">				<span class="keyword">continue</span>;<span class="comment">//任意两个平面相同，则不会有三重交点，跳过此循环</span></span><br><span class="line"></span><br><span class="line">			<span class="comment">//计算三个平面的交集，如果交集的对象可以转换为一个Kernel::Point_3类型的指针，则三个平面相交于一点</span></span><br><span class="line">			CGAL::Object obj = CGAL::<span class="built_in">intersection</span>(*plane1, *plane2, *plane3);</span><br><span class="line">			<span class="keyword">if</span> (<span class="type">const</span> Kernel::Point_3* pt = CGAL::<span class="built_in">object_cast</span>&lt;Kernel::Point_3&gt;(&amp;obj))</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">//复制三重交点的坐标，存储点</span></span><br><span class="line">				Kernel::Point_3* new_point = <span class="keyword">new</span> Kernel::<span class="built_in">Point_3</span>(*pt);</span><br><span class="line">				_triplet_intersections[plane1][plane2][plane3] = new_point;</span><br><span class="line">				intersecting_points_.<span class="built_in">push_back</span>(new_point);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				<span class="keyword">continue</span>;<span class="comment">//未得到交点的两种原因：（1）面是平行的；（2）面相交于同一条线上。</span></span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="确定相交面（及其交点）"><a href="#确定相交面（及其交点）" class="headerlink" title="确定相交面（及其交点）"></a>确定相交面（及其交点）</h3><p>这一小节的目的是确定mesh_candidate内某个大块面与哪些大块面存在相交关系。遍历每个面，取出当前面的下标index_face_i及其平面方程plane_face_i。再套一个同样的遍历取候选切面f，通过函数HypothesisPlaneProcess::compute_intersections()计算两个面的交点数量，根据相交点的情况将相交面存入intersecting_faces。<br>为便于回顾，下述代码省略了一些细枝末节的判断和属性别名。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::vector&lt;Polygon_mesh::Face_index&gt; <span class="title">all_faces</span><span class="params">(mesh_candidate.faces().begin(), mesh_candidate.faces().end())</span></span>;<span class="comment">//容器_所有候选面</span></span><br><span class="line"><span class="keyword">for</span> (std::<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; all_faces.<span class="built_in">size</span>(); ++i)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//获取第i个面的索引和所在平面</span></span><br><span class="line">	Polygon_mesh::Face_index index_face_i = all_faces[i];</span><br><span class="line">	<span class="type">const</span> Kernel::Plane_3* plane_face_i = face_supporting_planes[index_face_i];</span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取相应的属性映射</span></span><br><span class="line">	<span class="keyword">typename</span> Polygon_mesh::<span class="keyword">template</span> Property_map&lt;Polygon_mesh::Face_index, <span class="type">const</span> Kernel::Plane_3*&gt; face_supporting_planes =</span><br><span class="line">		mesh_candidate.<span class="keyword">template</span> <span class="built_in">property_map</span>&lt;Polygon_mesh::Face_index, <span class="type">const</span> Kernel::Plane_3*&gt;(<span class="string">&quot;f:supp_plane&quot;</span>).first;<span class="comment">//属性映射_每个面的支撑平面</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//2.1、遍历所有候选面，将与第i个面相交的面存入集合 intersecting_faces</span></span><br><span class="line">	std::set&lt;Polygon_mesh::Face_index&gt; intersecting_faces;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> f : mesh_candidate.<span class="built_in">faces</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//2.2、判断面 f 是否与平面 plane_cutting 相交</span></span><br><span class="line">		<span class="type">const</span> Kernel::Plane_3* plane_cutting = face_supporting_planes[index_face_i];<span class="comment">//获取给定面作为切割面</span></span><br><span class="line">		<span class="built_in">CGAL_assertion</span>(plane_cutting != <span class="literal">nullptr</span>);<span class="comment">//检查平面是否为空指针</span></span><br><span class="line"></span><br><span class="line">		std::vector&lt;Polygon_mesh::Vertex_index&gt; existing_vts;<span class="comment">//平面相交的已有顶点下标</span></span><br><span class="line">		std::vector&lt;EdgePos&gt; new_vts;<span class="comment">//平面相交的新生成的顶点</span></span><br><span class="line">		<span class="built_in">compute_intersections</span>(mesh_candidate, f, plane_cutting, existing_vts, new_vts);<span class="comment">//计算交点</span></span><br><span class="line"></span><br><span class="line">		<span class="type">bool</span> is_intersect_fPlane = <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">if</span> (existing_vts.<span class="built_in">size</span>() == <span class="number">2</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (!<span class="built_in">halfedge_exists</span>(existing_vts[<span class="number">0</span>], existing_vts[<span class="number">1</span>], mesh_candidate))</span><br><span class="line">				is_intersect_fPlane = <span class="literal">true</span>;<span class="comment">//2个已有的顶点与plane_cutting相交且两点不在同一条边上</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (existing_vts.<span class="built_in">size</span>() + new_vts.<span class="built_in">size</span>() == <span class="number">2</span>)</span><br><span class="line">			is_intersect_fPlane = <span class="literal">true</span>;<span class="comment">//已有+新生成的共两个点与plane_cutting相交</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (is_intersect_fPlane)</span><br><span class="line">			intersecting_faces.<span class="built_in">insert</span>(f);<span class="comment">//如果f和第i个面所在的平面相交,将f加入到intersecting_faces</span></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (intersecting_faces.<span class="built_in">empty</span>())</span><br><span class="line">		<span class="keyword">continue</span>;<span class="comment">//对第i个候选面，没有与之相交的候选面，则跳过</span></span><br><span class="line">	<span class="function">std::vector&lt;Polygon_mesh::Face_index&gt; <span class="title">cutting_faces</span><span class="params">(intersecting_faces.begin(), intersecting_faces.end())</span></span>;<span class="comment">//容器_与第i个候选面相交的其他候选面</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//3、使用与 index_face_i 相交的平面分割 index_face_i</span></span><br><span class="line">	<span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码中创造了两个变量，存储mesh_candidate已有点下标的existing_vts和存储两平面相交产生的新点的对象new_vts。由于它们的值取决于compute_intersections()，而后面相交关系的if判断也是基于这两变量得到的，不难发现compute_intersections()的交点计算过程才是这小节的重点。来看看compute_intersections函数中对这这两个变量的处理逻辑。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">HypothesisPlaneProcess::compute_intersections</span><span class="params">(<span class="type">const</span> Polygon_mesh &amp; mesh, Polygon_mesh::Face_index face, <span class="type">const</span> Kernel::Plane_3 * plane_cutting, std::vector&lt;Polygon_mesh::Vertex_index&gt;&amp; existing_vts, std::vector&lt;EdgePos&gt;&amp; new_vts)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	existing_vts.<span class="built_in">clear</span>();</span><br><span class="line">	new_vts.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">typename</span> Polygon_mesh::<span class="keyword">template</span> Property_map&lt;Polygon_mesh::Face_index, <span class="type">const</span> Kernel::Plane_3*&gt; face_supporting_planes =</span><br><span class="line">		mesh.<span class="keyword">template</span> <span class="built_in">property_map</span>&lt;Polygon_mesh::Face_index, <span class="type">const</span> Kernel::Plane_3*&gt;(<span class="string">&quot;f:supp_plane&quot;</span>).first;<span class="comment">//属性映射_每个给定面所在的支撑面</span></span><br><span class="line">	<span class="type">const</span> Kernel::Plane_3* supporting_plane = face_supporting_planes[face];</span><br><span class="line">	<span class="keyword">if</span> (supporting_plane == plane_cutting)</span><br><span class="line">		<span class="keyword">return</span>;<span class="comment">//给定面与切割平面相同，则不需计算交点，退出函数</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">typename</span> Polygon_mesh::<span class="keyword">template</span> Property_map&lt;Polygon_mesh::Edge_index, std::set&lt;<span class="type">const</span> Kernel::Plane_3*&gt; &gt; edge_supporting_planes</span><br><span class="line">		= mesh.<span class="keyword">template</span> property_map&lt;Polygon_mesh::Edge_index, std::set&lt;<span class="type">const</span> Kernel::Plane_3*&gt; &gt;(<span class="string">&quot;e:supp_plane&quot;</span>).first;<span class="comment">//属性映射_每条边所在平面的集合</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	Polygon_mesh::Halfedge_index cur = mesh.<span class="built_in">halfedge</span>(face);<span class="comment">//给定面的第一个半边的索引</span></span><br><span class="line">	Polygon_mesh::Halfedge_index end = cur;<span class="comment">//记录 cur ，用于结束循环</span></span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		<span class="comment">//获取半边和其所在的平面</span></span><br><span class="line">		Polygon_mesh::Edge_index ed = mesh.<span class="built_in">edge</span>(cur);</span><br><span class="line">		<span class="type">const</span> std::set&lt;<span class="type">const</span> Kernel::Plane_3*&gt;&amp; supporting_planes = edge_supporting_planes[ed];</span><br><span class="line">		<span class="keyword">if</span> (supporting_planes.<span class="built_in">find</span>(plane_cutting) != supporting_planes.<span class="built_in">end</span>())</span><br><span class="line">			<span class="keyword">return</span>;<span class="comment">//边的平面集合中包含切割平面，则说明当前边在切割平面上，退出函数</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//获取边的两个顶点及坐标</span></span><br><span class="line">		Polygon_mesh::Vertex_index s_vd = mesh.<span class="built_in">source</span>(cur);</span><br><span class="line">		Polygon_mesh::Vertex_index t_vd = mesh.<span class="built_in">target</span>(cur);</span><br><span class="line">		<span class="type">const</span> Kernel::Point_3&amp; s = mesh.<span class="built_in">points</span>()[s_vd];</span><br><span class="line">		<span class="type">const</span> Kernel::Point_3&amp; t = mesh.<span class="built_in">points</span>()[t_vd];</span><br><span class="line"></span><br><span class="line">		<span class="comment">//判断两个顶点相对于切割平面的位置</span></span><br><span class="line">		CGAL::Oriented_side s_side = plane_cutting-&gt;<span class="built_in">oriented_side</span>(s);</span><br><span class="line">		CGAL::Oriented_side t_side = plane_cutting-&gt;<span class="built_in">oriented_side</span>(t);</span><br><span class="line">		<span class="keyword">if</span> (t_side == CGAL::ON_ORIENTED_BOUNDARY)<span class="comment">//目标顶点在plane_cutting上</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (s_side == CGAL::ON_ORIENTED_BOUNDARY)<span class="comment">//源顶点在plane_cutting上</span></span><br><span class="line">				<span class="keyword">return</span>;<span class="comment">//边在plane_cutting上，不需计算交点，退出函数</span></span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				existing_vts.<span class="built_in">push_back</span>(t_vd);<span class="comment">//目标点为交点，添加到已有顶点集</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">if</span> ((s_side == CGAL::ON_POSITIVE_SIDE &amp;&amp; t_side == CGAL::ON_NEGATIVE_SIDE) ||</span><br><span class="line">				(s_side == CGAL::ON_NEGATIVE_SIDE &amp;&amp; t_side == CGAL::ON_POSITIVE_SIDE))<span class="comment">//源顶点和目标顶点在plane_cutting的两侧</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">//当前边与plane_cutting在内部相交</span></span><br><span class="line">				<span class="comment">//计算两顶点到plane_cutting的距离的平方</span></span><br><span class="line">				FT s_sdist = CGAL::<span class="built_in">squared_distance</span>(*plane_cutting, s);</span><br><span class="line">				FT t_sdist = CGAL::<span class="built_in">squared_distance</span>(*plane_cutting, t);</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (s_sdist &lt;= CGAL::<span class="built_in">snap_squared_distance_threshold</span>&lt;FT&gt;())<span class="comment">//源顶点到plane_cutting的距离小于阈值，说明plane_cutting在源顶点处切割</span></span><br><span class="line">					existing_vts.<span class="built_in">push_back</span>(s_vd);<span class="comment">//源顶点添加到已有顶点集</span></span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">					<span class="keyword">if</span> (t_sdist &lt;= CGAL::<span class="built_in">snap_squared_distance_threshold</span>&lt;FT&gt;())<span class="comment">//目标顶点到plane_cutting的距离小于阈值</span></span><br><span class="line">						existing_vts.<span class="built_in">push_back</span>(t_vd);<span class="comment">//目标顶点添加到已有顶点集</span></span><br><span class="line">					<span class="keyword">else</span></span><br><span class="line">					&#123;</span><br><span class="line">						<span class="type">const</span> Kernel::Plane_3* plane1 = *(supporting_planes.<span class="built_in">begin</span>());<span class="comment">//边所在平面中的第一个平面</span></span><br><span class="line">						<span class="type">const</span> Kernel::Plane_3* plane2 = *(supporting_planes.<span class="built_in">rbegin</span>());<span class="comment">//边所在平面中的最后一个平面</span></span><br><span class="line">						<span class="type">const</span> Kernel::Plane_3* plane3 = <span class="built_in">const_cast</span>&lt;<span class="type">const</span> Kernel::Plane_3*&gt;(plane_cutting);<span class="comment">//获取plane_cutting</span></span><br><span class="line"></span><br><span class="line">						<span class="comment">//如果切割平面和当前边所在的两个平面不同，则三个平面可构成三重交点</span></span><br><span class="line">						<span class="keyword">if</span> (plane3 != plane1 &amp;&amp; plane3 != plane2)</span><br><span class="line">						&#123;</span><br><span class="line">							<span class="built_in">sort_increasing</span>(plane1, plane2, plane3);<span class="comment">//三个平面按指针升序的顺序排序，便于查询</span></span><br><span class="line">							<span class="comment">//const Kernel::Point_3* p = query_intersection(plane1, plane2, plane3);//查询三个平面的交点</span></span><br><span class="line">							<span class="comment">//2023.11.5 修改——————</span></span><br><span class="line">							<span class="comment">//计算三个平面的交集，如果交集的对象可以转换为一个Kernel::Point_3类型的指针，则三个平面相交于一点</span></span><br><span class="line">							CGAL::Object obj = CGAL::<span class="built_in">intersection</span>(*plane1, *plane2, *plane3);</span><br><span class="line">							Kernel::Point_3* p;</span><br><span class="line">							<span class="keyword">if</span> (<span class="type">const</span> Kernel::Point_3* pt = CGAL::<span class="built_in">object_cast</span>&lt;Kernel::Point_3&gt;(&amp;obj))</span><br><span class="line">							&#123;</span><br><span class="line">								<span class="comment">//复制三重交点的坐标，存储点</span></span><br><span class="line">								p = <span class="keyword">new</span> Kernel::<span class="built_in">Point_3</span>(*pt);</span><br><span class="line">								_triplet_intersections[plane1][plane2][plane3] = p;</span><br><span class="line">							&#125;</span><br><span class="line">							<span class="keyword">else</span></span><br><span class="line">								p = <span class="literal">nullptr</span>;</span><br><span class="line">							<span class="comment">//————————————</span></span><br><span class="line">							<span class="keyword">if</span> (p)<span class="comment">//查询到有交点</span></span><br><span class="line">							&#123;</span><br><span class="line">								<span class="keyword">if</span> (CGAL::<span class="built_in">squared_distance</span>(*p, s) &lt;= CGAL::<span class="built_in">snap_squared_distance_threshold</span>&lt;FT&gt;())<span class="comment">//交点和源顶点的距离小于阈值，交点视为源顶点</span></span><br><span class="line">									existing_vts.<span class="built_in">push_back</span>(s_vd);</span><br><span class="line">								<span class="keyword">else</span> <span class="keyword">if</span> (CGAL::<span class="built_in">squared_distance</span>(*p, t) &lt;= CGAL::<span class="built_in">snap_squared_distance_threshold</span>&lt;FT&gt;())<span class="comment">//交点和目标顶点的距离小于阈值，视为目标顶点</span></span><br><span class="line">									existing_vts.<span class="built_in">push_back</span>(t_vd);<span class="comment">//点存入已有顶点集</span></span><br><span class="line">								<span class="keyword">else</span></span><br><span class="line">									new_vts.<span class="built_in">push_back</span>(<span class="built_in">EdgePos</span>(ed, p));<span class="comment">//将交点与当前边构成EdgePos对象，加入到新生成的顶点集</span></span><br><span class="line">							&#125;</span><br><span class="line">							<span class="keyword">else</span></span><br><span class="line">								std::cerr &lt;&lt; <span class="string">&quot;Fatal error: should have intersection&quot;</span> &lt;&lt; std::endl;<span class="comment">//错误_不存在交点</span></span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">else</span></span><br><span class="line">							std::cerr &lt;&lt; <span class="string">&quot;Fatal error: should not have duplicated planes.&quot;</span> &lt;&lt; std::endl;<span class="comment">//错误_出现重复平面</span></span><br><span class="line">					&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">// Nothing needs to do here, we will test the next edge</span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		cur = mesh.<span class="built_in">next</span>(cur);</span><br><span class="line"></span><br><span class="line">	&#125; <span class="keyword">while</span> (cur != end);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>师弟SY曾与我探讨了这块的内容（感谢.jpg），一并总结下：<br>先根据当前面在mesh_candidate的下标，循环取该面的半边结构cur，得到该半边的两个顶点s和t。将这两个点与（相交）候选切面的平面方程plane_cutting做位置上的判断，有这么几种情况：<br>（1）边的两个顶点都在plane_cutting上，则当前面与候选切面刚好相交于一条线上，直接retrun不需要该候选切面来给当前面做切割；<br>（2）仅有一个点t在plane_cutting上，将这个点记录到existing_vts中。不对点s做这个判断是为了避免在别的半边那里重复记录，不理解的话跳去SegMeshCandidate()中回顾2.2两个面的相交判断。若后续还能记录到另一个点到existing_vts&#x2F;new_vts，则这两点的连线为切线。<br>（3）s和t分别在plane_cutting两侧。先分别对两点做了个到候选切面的距离判断，相当于更宽松条件下的（2）情况。若s与t离候选切面较远，那取出生成当前边st的两个平面（应该是当前面和包围盒上的某个面），与plane_cutting一起计算出三重交点p，根据p与s、t的距离判断来将p存入existing_vts或new_vts。<br>挺绕的，可以说是相当地严谨…不对不对，少了种相切情况的if判断，是后来师弟提出一个问题：为什么不考虑new_vts.size() &#x3D;&#x3D; 2的情况？当时我少了根筋给了他否定的答复，但现在重读代码，感觉确实是存在候选切面与当前面两个边相交于新点的情况，不知为什么作者没加入这个判断。总之，根据compute_intersections()计算的交点个数，可以确定当前面与候选切面是否会相交，与当前面index_face_i的相交切面将存入到intersecting_faces中。</p>
<h3 id="平面分割"><a href="#平面分割" class="headerlink" title="平面分割"></a>平面分割</h3><p>开始对当前面进行切割。以faces_to_be_cut存储待分割的面，按序取一个候选切面进行切割后，原来的面不再存在，它被多个新的面片取代，将它们存入faces_to_be_cut，并在下一轮循环中使用下一个候选切面来切割。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//3、使用与 index_face_i 相交的平面分割 index_face_i </span></span><br><span class="line"><span class="comment">//每次切割后，原来的面不再存在，它被多个块取代，每个块都将被另一个平面切割</span></span><br><span class="line">std::vector&lt;Polygon_mesh::Face_index&gt; faces_to_be_cut;<span class="comment">//存储需要被分割的面</span></span><br><span class="line">faces_to_be_cut.<span class="built_in">push_back</span>(index_face_i);<span class="comment">//先添加当前的第i个面</span></span><br><span class="line"><span class="keyword">while</span> (!intersecting_faces.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//以第一个相交面作为切割面</span></span><br><span class="line">	Polygon_mesh::Face_index cutting_face = *(intersecting_faces.<span class="built_in">begin</span>());<span class="comment">//切割面的索引</span></span><br><span class="line">	<span class="type">const</span> Kernel::Plane_3* cutting_plane = face_supporting_planes[cutting_face];<span class="comment">//获取切割面所在平面</span></span><br><span class="line"></span><br><span class="line">	std::set&lt;Polygon_mesh::Face_index&gt; new_faces;                <span class="comment">//存储切割后产生的新面</span></span><br><span class="line">	std::set&lt;Polygon_mesh::Face_index&gt; remained_faces;        <span class="comment">//存储还需被切割的面</span></span><br><span class="line">	<span class="keyword">for</span> (std::<span class="type">size_t</span> j = <span class="number">0</span>; j &lt; faces_to_be_cut.<span class="built_in">size</span>(); ++j)</span><br><span class="line">	&#123;</span><br><span class="line">		Polygon_mesh::Face_index current_face = faces_to_be_cut[j];<span class="comment">//被切割的面</span></span><br><span class="line">		std::vector&lt;Polygon_mesh::Face_index&gt; tmp = <span class="built_in">split_plane</span>(current_face, cutting_plane, mesh_candidate);<span class="comment">//调用split_plane函数对这个面进行切割</span></span><br><span class="line">		new_faces.<span class="built_in">insert</span>(tmp.<span class="built_in">begin</span>(), tmp.<span class="built_in">end</span>());<span class="comment">//把这些新的面加入到new_faces中</span></span><br><span class="line">		<span class="keyword">if</span> (tmp.<span class="built_in">empty</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			remained_faces.<span class="built_in">insert</span>(current_face);<span class="comment">//没有发生切割，将该面加入到 remained_faces 待后续进行切割</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//把 new_faces 中的面作为下一轮需要被切割的面</span></span><br><span class="line">	faces_to_be_cut = std::<span class="built_in">vector</span>&lt;Polygon_mesh::Face_index&gt;(new_faces.<span class="built_in">begin</span>(), new_faces.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">	<span class="comment">//把 remained_faces 中的面也加入到需要被切割的面</span></span><br><span class="line">	faces_to_be_cut.<span class="built_in">insert</span>(faces_to_be_cut.<span class="built_in">end</span>(), remained_faces.<span class="built_in">begin</span>(), remained_faces.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">	intersecting_faces.<span class="built_in">erase</span>(cutting_face);<span class="comment">//将被切割面从相交的面中移除</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//4、所有和第i个面相交的面 cutting_faces 都会被第i个面所在的平面 index_face_i 切割</span></span><br><span class="line"><span class="keyword">for</span> (std::<span class="type">size_t</span> j = <span class="number">0</span>; j &lt; cutting_faces.<span class="built_in">size</span>(); ++j)</span><br><span class="line">	<span class="built_in">split_plane</span>(cutting_faces[j], plane_face_i, mesh_candidate);</span><br></pre></td></tr></table></figure>
<p>核心的分割过程在HypothesisPlaneProcess::split_plane()函数和HypothesisPlaneProcess::split_edge()函数中，本质是使用CGAL::Euler::split_edge()来在要分割的边上插入一个新顶点，并返回指向新顶点的半边索引；用CGAL::Euler::split_face()在给定面上插入一条新边，最后为新的两个面片赋予所属平面、所属区域等属性。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::vector&lt;Polygon_mesh::Face_index&gt; <span class="title">HypothesisPlaneProcess::split_plane</span><span class="params">(Polygon_mesh::Face_index face, <span class="type">const</span> Kernel::Plane_3 * cutting_plane, Polygon_mesh &amp; mesh)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::vector&lt;Polygon_mesh::Face_index&gt; new_faces;<span class="comment">//容器_切割后产生的新面的索引</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//1、定义属性映射</span></span><br><span class="line">	<span class="keyword">typename</span> Polygon_mesh::<span class="keyword">template</span> Property_map&lt;Polygon_mesh::Face_index, <span class="type">const</span> Kernel::Plane_3*&gt; face_supporting_planes =</span><br><span class="line">		mesh.<span class="keyword">template</span> <span class="built_in">property_map</span>&lt;Polygon_mesh::Face_index, <span class="type">const</span> Kernel::Plane_3*&gt;(<span class="string">&quot;f:supp_plane&quot;</span>).first;<span class="comment">//属性映射_每个面的支撑面</span></span><br><span class="line"></span><br><span class="line">	<span class="type">const</span> Kernel::Plane_3* supporting_plane = face_supporting_planes[face];</span><br><span class="line">	<span class="keyword">if</span> (supporting_plane == cutting_plane)</span><br><span class="line">		<span class="keyword">return</span> new_faces;<span class="comment">//给定面所在的平面和切割平面相同，则不需要切割，返回空向量</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">typename</span> Polygon_mesh::<span class="keyword">template</span> Property_map&lt;Polygon_mesh::Face_index, CGAL::internal::Planar_segment&lt;Kernel&gt;*&gt; face_supporting_segments =</span><br><span class="line">		mesh.<span class="keyword">template</span> property_map&lt;Polygon_mesh::Face_index, CGAL::internal::Planar_segment&lt;Kernel&gt;*&gt;(<span class="string">&quot;f:supp_segment&quot;</span>).first;<span class="comment">//属性映射_每个面的切割面</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">typename</span> Polygon_mesh::<span class="keyword">template</span> Property_map&lt;Polygon_mesh::Edge_index, std::set&lt;<span class="type">const</span> Kernel::Plane_3*&gt; &gt; edge_supporting_planes =</span><br><span class="line">		mesh.<span class="keyword">template</span> property_map&lt;Polygon_mesh::Edge_index, std::set&lt;<span class="type">const</span> Kernel::Plane_3*&gt; &gt;(<span class="string">&quot;e:supp_plane&quot;</span>).first;<span class="comment">//属性映射_每条边的支撑面</span></span><br><span class="line">	CGAL::internal::Planar_segment&lt;Kernel&gt;* supporting_segment = face_supporting_segments[face];</span><br><span class="line"></span><br><span class="line">	<span class="comment">//2023.11.23new:添加新的属性映射以表示平面所属的区域</span></span><br><span class="line">	Polygon_mesh::Property_map&lt;Polygon_mesh::Face_index, std::<span class="type">size_t</span>&gt; face_region_map</span><br><span class="line">		= mesh.<span class="built_in">property_map</span>&lt;Polygon_mesh::Face_index, std::<span class="type">size_t</span>&gt;(<span class="string">&quot;f:region_map&quot;</span>).first;<span class="comment">//每个面的所属区域</span></span><br><span class="line">	<span class="type">size_t</span> index_region = face_region_map[face];</span><br><span class="line">	<span class="comment">//—————————————————————————</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//2、计算交点，分情况分析切割情况</span></span><br><span class="line">	std::vector&lt;Polygon_mesh::Vertex_index&gt; existing_vts;<span class="comment">//容器_与切割面相交的已有顶点</span></span><br><span class="line">	std::vector&lt;EdgePos&gt; new_vts;<span class="comment">//容器_与切割面相交的新生成顶点</span></span><br><span class="line">	<span class="built_in">compute_intersections</span>(mesh, face, cutting_plane, existing_vts, new_vts);<span class="comment">//计算给定面和切割平面的交点</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (existing_vts.<span class="built_in">size</span>() + new_vts.<span class="built_in">size</span>() != <span class="number">2</span>)</span><br><span class="line">		<span class="keyword">return</span> new_faces;<span class="comment">//交点数没有两个，则切割失败，返回空向量</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (existing_vts.<span class="built_in">size</span>() == <span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (existing_vts[<span class="number">0</span>] == existing_vts[<span class="number">1</span>])</span><br><span class="line">			<span class="keyword">return</span> new_faces;<span class="comment">//两交点为同一个顶点，返回空向量</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">halfedge_exists</span>(existing_vts[<span class="number">0</span>], existing_vts[<span class="number">1</span>], mesh))</span><br><span class="line">			<span class="keyword">return</span> new_faces;<span class="comment">//两交点之间已存在一条边，返回空向量</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//确定两交点的半边</span></span><br><span class="line">	Polygon_mesh::Halfedge_index h0 = Polygon_mesh::<span class="built_in">null_halfedge</span>();</span><br><span class="line">	Polygon_mesh::Halfedge_index h1 = Polygon_mesh::<span class="built_in">null_halfedge</span>();</span><br><span class="line">	<span class="keyword">if</span> (existing_vts.<span class="built_in">size</span>() == <span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//cutting_plane 在两个已有顶点处切割给定面（而不是一条边）</span></span><br><span class="line">		h0 = mesh.<span class="built_in">halfedge</span>(existing_vts[<span class="number">0</span>]);<span class="comment">//第一个已有顶点所在半边为h0</span></span><br><span class="line">		h1 = mesh.<span class="built_in">halfedge</span>(existing_vts[<span class="number">1</span>]);<span class="comment">//第二个已有顶点所在半边为h1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (existing_vts.<span class="built_in">size</span>() == <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//cutting_plane 在一个已有顶点和一条边的内部切割给定面</span></span><br><span class="line">		h0 = mesh.<span class="built_in">halfedge</span>(existing_vts[<span class="number">0</span>]);</span><br><span class="line">		h1 = <span class="built_in">split_edge</span>(mesh, new_vts[<span class="number">0</span>], cutting_plane);<span class="comment">//以新生成顶点的边为h1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (new_vts.<span class="built_in">size</span>() == <span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//cutting_plane 在两条边的内部切割给定面</span></span><br><span class="line">		h0 = <span class="built_in">split_edge</span>(mesh, new_vts[<span class="number">0</span>], cutting_plane);</span><br><span class="line">		h1 = <span class="built_in">split_edge</span>(mesh, new_vts[<span class="number">1</span>], cutting_plane);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">CGAL_assertion</span>(h0 != Polygon_mesh::<span class="built_in">null_halfedge</span>());<span class="comment">//断言_h0、h1不是空的半边索引</span></span><br><span class="line">	<span class="built_in">CGAL_assertion</span>(h1 != Polygon_mesh::<span class="built_in">null_halfedge</span>());</span><br><span class="line"></span><br><span class="line">	<span class="comment">//为了分割平面，边h0和h1必须附着在同一个面上</span></span><br><span class="line">	<span class="keyword">if</span> (mesh.<span class="built_in">face</span>(h0) != face)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//h0所在的面不是给定面</span></span><br><span class="line">		Polygon_mesh::Halfedge_index end = h0;<span class="comment">//记录h0的初始值，用于结束循环</span></span><br><span class="line">		<span class="keyword">do</span> &#123;</span><br><span class="line">			h0 = mesh.<span class="built_in">opposite</span>(mesh.<span class="built_in">next</span>(h0));<span class="comment">//将h0沿着给定面的边界顺时针移动一步</span></span><br><span class="line">			<span class="keyword">if</span> (mesh.<span class="built_in">face</span>(h0) == face)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125; <span class="keyword">while</span> (h0 != end);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">CGAL_assertion</span>(mesh.<span class="built_in">face</span>(h0) == face);<span class="comment">//断言_h0所在的面是给定面</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (mesh.<span class="built_in">face</span>(h1) != face)</span><br><span class="line">	&#123;</span><br><span class="line">		Polygon_mesh::Halfedge_index end = h1;</span><br><span class="line">		<span class="keyword">do</span> &#123;</span><br><span class="line">			h1 = mesh.<span class="built_in">opposite</span>(mesh.<span class="built_in">next</span>(h1));</span><br><span class="line">			<span class="keyword">if</span> (mesh.<span class="built_in">face</span>(h1) == face)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125; <span class="keyword">while</span> (h1 != end);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">CGAL_assertion</span>(mesh.<span class="built_in">face</span>(h1) == face);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//以h0和h1为参数，在给定面上插入一条新边，返回新边对应的一个半边索引</span></span><br><span class="line">	Polygon_mesh::Halfedge_index h = CGAL::Euler::<span class="built_in">split_face</span>(h0, h1, mesh);</span><br><span class="line">	<span class="keyword">if</span> (h == Polygon_mesh::<span class="built_in">null_halfedge</span>() || mesh.<span class="built_in">face</span>(h) == Polygon_mesh::<span class="built_in">null_face</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		std::cerr &lt;&lt; <span class="string">&quot;Fatal error. could not split face&quot;</span> &lt;&lt; std::endl;<span class="comment">//错误_边插入失败/新边没有对应的有效面</span></span><br><span class="line">		<span class="keyword">return</span> new_faces;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//3、平面分割/赋值属性映射</span></span><br><span class="line">	<span class="comment">//在边h的属性映射_支撑面中加入给定面和切割平面</span></span><br><span class="line">	Polygon_mesh::Edge_index e = mesh.<span class="built_in">edge</span>(h);</span><br><span class="line">	edge_supporting_planes[e].<span class="built_in">insert</span>(supporting_plane);</span><br><span class="line">	edge_supporting_planes[e].<span class="built_in">insert</span>(cutting_plane);</span><br><span class="line">	<span class="built_in">CGAL_assertion</span>(edge_supporting_planes[e].<span class="built_in">size</span>() == <span class="number">2</span>);<span class="comment">//断言_边h所在的平面集合中只有两个元素</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Now the two faces</span></span><br><span class="line">	Polygon_mesh::Face_index f1 = mesh.<span class="built_in">face</span>(h);<span class="comment">//获取新边所在的一个半边对应的面索引</span></span><br><span class="line">	face_supporting_segments[f1] = supporting_segment;<span class="comment">//将给定面所在的平面段赋值给f1所在的平面段</span></span><br><span class="line">	face_supporting_planes[f1] = supporting_plane;<span class="comment">//将给定面所在的平面赋值给f1所在的平面</span></span><br><span class="line">	face_region_map[f1] = index_region;<span class="comment">//给定面对应的点云区域赋值给f1</span></span><br><span class="line">	new_faces.<span class="built_in">push_back</span>(f1);<span class="comment">//将f1加入到容器_新面中</span></span><br><span class="line"></span><br><span class="line">	Polygon_mesh::Face_index f2 = mesh.<span class="built_in">face</span>(mesh.<span class="built_in">opposite</span>(h));<span class="comment">//获取新边所在的另一个半边对应的面索引</span></span><br><span class="line">	face_supporting_segments[f2] = supporting_segment;</span><br><span class="line">	face_supporting_planes[f2] = supporting_plane;</span><br><span class="line">	new_faces.<span class="built_in">push_back</span>(f2);</span><br><span class="line">	face_region_map[f2] = index_region;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> new_faces;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Polygon_mesh::Halfedge_index <span class="title">HypothesisPlaneProcess::split_edge</span><span class="params">(Polygon_mesh &amp; mesh, <span class="type">const</span> EdgePos &amp; ep, <span class="type">const</span> Kernel::Plane_3 * cutting_plane)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 这个函数将分割由 &#x27;ep&#x27; 表示的边</span></span><br><span class="line">	<span class="comment">// - 给新生成的边分配支撑平面</span></span><br><span class="line">	<span class="comment">// - 返回指向新生成顶点的半边索引</span></span><br><span class="line">	<span class="comment">// 函数内部使用了Euler split_edge()操作</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//1、获取mesh的属性映射</span></span><br><span class="line">	<span class="keyword">typename</span> Polygon_mesh::<span class="keyword">template</span> Property_map&lt;Polygon_mesh::Edge_index, std::set&lt;<span class="type">const</span> Kernel::Plane_3*&gt; &gt; edge_supporting_planes</span><br><span class="line">		= mesh.<span class="keyword">template</span> property_map&lt;Polygon_mesh::Edge_index, std::set&lt;<span class="type">const</span> Kernel::Plane_3*&gt; &gt;(<span class="string">&quot;e:supp_plane&quot;</span>).first;<span class="comment">//属性映射_每个边所在的支撑面</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">typename</span> Polygon_mesh::<span class="keyword">template</span> Property_map&lt;Polygon_mesh::Vertex_index, std::set&lt;<span class="type">const</span> Kernel::Plane_3*&gt; &gt; vertex_supporting_planes</span><br><span class="line">		= mesh.<span class="keyword">template</span> property_map&lt;Polygon_mesh::Vertex_index, std::set&lt;<span class="type">const</span> Kernel::Plane_3*&gt; &gt;(<span class="string">&quot;v:supp_plane&quot;</span>).first;<span class="comment">//属性映射_每个顶点所在的支撑面</span></span><br><span class="line"></span><br><span class="line">	std::set&lt;<span class="type">const</span> Kernel::Plane_3*&gt; sfs = edge_supporting_planes[ep.edge];<span class="comment">//引用_分割边所在的平面//不使用常量引用，因为会在分割后失效</span></span><br><span class="line">	<span class="built_in">CGAL_assertion</span>(sfs.<span class="built_in">size</span>() == <span class="number">2</span>);<span class="comment">//断言_集合仅有两个元素（分割的两个面）</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//2、分割操作</span></span><br><span class="line">	Polygon_mesh::Halfedge_index h = CGAL::Euler::<span class="built_in">split_edge</span>(mesh.<span class="built_in">halfedge</span>(ep.edge), mesh);<span class="comment">//在要分割的边上插入一个新顶点，并返回指向新顶点的半边索引</span></span><br><span class="line">	<span class="keyword">if</span> (h == Polygon_mesh::<span class="built_in">null_halfedge</span>())</span><br><span class="line">		<span class="keyword">return</span> h;<span class="comment">//分割失败，返回空的半边索引</span></span><br><span class="line"></span><br><span class="line">	Polygon_mesh::Vertex_index v = mesh.<span class="built_in">target</span>(h);<span class="comment">//新顶点对应的顶点索引</span></span><br><span class="line">	<span class="keyword">if</span> (v == Polygon_mesh::<span class="built_in">null_vertex</span>())</span><br><span class="line">		<span class="keyword">return</span> Polygon_mesh::<span class="built_in">null_halfedge</span>();<span class="comment">//索引不存在，返回空的半边索引</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">typename</span> Polygon_mesh::<span class="keyword">template</span> Property_map&lt;Polygon_mesh::Vertex_index, Kernel::Point_3&gt;&amp; coords</span><br><span class="line">		= mesh.<span class="built_in">points</span>();<span class="comment">//属性映射_每个顶点坐标</span></span><br><span class="line">	coords[v] = *ep.pos;<span class="comment">//设置新顶点的坐标为EdgePos对象中存储的交点坐标</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取新生成的两条边索引和其所在的平面</span></span><br><span class="line">	Polygon_mesh::Edge_index e1 = mesh.<span class="built_in">edge</span>(h);</span><br><span class="line">	edge_supporting_planes[e1] = sfs;</span><br><span class="line">	Polygon_mesh::Edge_index e2 = mesh.<span class="built_in">edge</span>(mesh.<span class="built_in">next</span>(h));</span><br><span class="line">	edge_supporting_planes[e2] = sfs;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//分割边所在的平面和切割面加入到新顶点的平面集合中</span></span><br><span class="line">	vertex_supporting_planes[v] = sfs;</span><br><span class="line">	vertex_supporting_planes[v].<span class="built_in">insert</span>(cutting_plane);</span><br><span class="line">	<span class="built_in">CGAL_assertion</span>(vertex_supporting_planes[v].<span class="built_in">size</span>() == <span class="number">3</span>);<span class="comment">//断言_新顶点的平面集合中有三个元素</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>经平面相交细分后，mesh_candidate中的大块面片被切分为若干细碎面片。它们仍称为候选面片集，其中存在某种能表示为建筑表面模型的最优组合，等待着我们去发掘。<br><img src="候选平面相交细分.png" alt="候选平面相交细分" title="候选平面相交细分"></p>
<h2 id="候选面集简化"><a href="#候选面集简化" class="headerlink" title="候选面集简化"></a>候选面集简化</h2><p>先叠个甲：这一章节的内容并非原PolyFit的内容，是我自己加进去的“改进”内容，目的是去除明显冗余的候选面片集。<br>从上一小节的尾图可以明显看到，最外层包围盒附近的一圈面片是“被截断的”，这种面片存在某条边不与别的面片相连。由于最终构成的建筑模型是边缘闭合的水密模型，这些被截断的面片显然不属于最终的模型组合，所以多加了这一节的内容对面集进行简化，以减轻后续的计算压力。更学术的说法是对候选面集添加“XX约束”，减少暴力分割过程中产生的明显冗余面，能在<sup>[21]</sup>、<sup>[22]</sup>等文献中看到这类优化思路的改进PolyFit算法。<br>ok来看代码中5.1的HypothesisPlaneProcess::SimpleMeshCandidate_V2函数，整个过程分为区域归类、标记缓冲区面片和边缘面查询三步，算法思路简述如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">①区域归类。对候选平面相交细分产生的每个分割面添加所属区域点云的属性映射，根据属性映射值查找属同一区域的多边形，将区域点云投影至多边形组成的平面。</span><br><span class="line">②标记缓冲区面片。对平面上的每个多边形，判断其内部是否存在投影点并进行标记。提取标记多边形的顶点，对所有使用该类顶点的多边形进行标记。该步骤是为了扩展被标记的候选平面，从而保证最终模型的闭合性。</span><br><span class="line">③边缘面查询。查询缓冲区面片集合中每个顶点被用于构成平面的次数。以次数为1的顶点所构成的平面视为边缘平面，需将其从面集内剔除。</span><br><span class="line">④重复步骤③，直至所有顶点被用于构成平面的次数不为1。输出该多边形网络为简化后的候选平面集合</span><br></pre></td></tr></table></figure>
<p>不过，上述思路是V1版本的。V1版本的代码写得过于激进，现在回看简直一坨。我记得是先统计mesh_candidate中所有顶点所邻接的候选面个数，若有的点只被唯一一个面“所拥有”，则认为该点的相关面为边缘面并予以剔除。方法粗看没什么问题，但在执行这个处理前，我对mesh_candidate做了次初筛，可能破坏了原mesh内部很多能构成封闭结构的面片，导致很容易把候选面删除到只剩一块块分离的小团块。V1先放那了仅做留档参考，V2在剔除面的判断上做了点改动，仍然是一坨，它没实现理想效果。下面来看看代码中的整个流程。</p>
<h3 id="区域归类"><a href="#区域归类" class="headerlink" title="区域归类"></a>区域归类</h3><p>先套一层遍历，每轮循环取一块聚类点云。每个聚类区域的点下标在之前被记录至分段分段s，以此提取出一个聚类的点坐标到points_region中。然后，使用supporting_plane()函数来拟合平面，该函数内部是调用CGAL::linear_least_squares_fitting_3的最小二乘拟合方法来计算平面系数。再然后，调用to_2d()方法，将聚类的每个点投影到平面上并存储到points_region_2。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt; Kernel::Point_3&gt; vi_covered;<span class="comment">//点云覆盖区域及邻近的点下标</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i_segment = <span class="number">0</span>; i_segment &lt; _cloud_plane-&gt;<span class="built_in">planar_segments</span>().<span class="built_in">size</span>(); i_segment++)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//1、获取区域点的覆盖区域</span></span><br><span class="line">	CGAL::internal::Planar_segment&lt;Kernel&gt;* s = _cloud_plane-&gt;<span class="built_in">planar_segments</span>()[i_segment];<span class="comment">//指针_分段区域</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取区域点云</span></span><br><span class="line">	std::vector&lt;Kernel::Point_3&gt; points_region;</span><br><span class="line">	<span class="keyword">for</span> (std::<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; s-&gt;<span class="built_in">size</span>(); ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		std::<span class="type">size_t</span> idx = s-&gt;<span class="built_in">at</span>(i);<span class="comment">//点索引</span></span><br><span class="line">		Kernel::Point_3 p = _cloud_plane-&gt;<span class="built_in">point_map</span>()[idx];</span><br><span class="line">		points_region.<span class="built_in">push_back</span>(p);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//三维点投影到平面</span></span><br><span class="line">	<span class="type">const</span> Kernel::Plane_3* plane_fitting = _cloud_plane-&gt;<span class="built_in">planar_segments</span>()[i_segment]-&gt;<span class="built_in">supporting_plane</span>();<span class="comment">//拟合平面</span></span><br><span class="line">	std::vector&lt;Kernel::Point_2&gt; points_region_2;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">const</span> Kernel::Point_3&amp; p : points_region)</span><br><span class="line">		points_region_<span class="number">2.</span><span class="built_in">push_back</span>(plane_fitting-&gt;<span class="built_in">to_2d</span>(p));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//2、...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="标记缓冲区面片"><a href="#标记缓冲区面片" class="headerlink" title="标记缓冲区面片"></a>标记缓冲区面片</h3><p>候选的大块面片在两两细分前，我用f:region_map记录了面片所属的聚类，根据下标把所有属于本轮聚类点云的候选面片都找出来，存入到faces_polygon中，相当于把处理对象从整个复杂的mesh_candicate收束到一个平面上。接着，对faces_polygon中的每个面f，将它上面的轮廓点集points_polygon同样投影到拟合面上，将得到的二维点存入points_polygon_2。根据这些点，判断聚类点points_region_2是否落在f内，只要有一个聚类点会投影到f上，那该f需被记录，将它的顶点存入到vi_covered中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2、遍历多边形上的每个面，将包含投影点及相关的面标记到 faces_covered</span></span><br><span class="line">std::vector&lt;Polygon_mesh::Face_index&gt; faces_polygon;<span class="comment">//存储多边形平面下标</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> Polygon_mesh::Face_index&amp; f : mesh_candidate.<span class="built_in">faces</span>())</span><br><span class="line">	<span class="keyword">if</span> (mesh_candidate.<span class="built_in">property_map</span>&lt;Polygon_mesh::Face_index, std::<span class="type">size_t</span>&gt;(<span class="string">&quot;f:region_map&quot;</span>).first[f] == i_segment)</span><br><span class="line">		faces_polygon.<span class="built_in">push_back</span>(f);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">GeometryCal obj_gc;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> Polygon_mesh::Face_index&amp; f : faces_polygon)</span><br><span class="line">&#123;</span><br><span class="line">	std::vector&lt;Kernel::Point_3&gt; points_polygon;</span><br><span class="line">	std::vector&lt;Polygon_mesh::Vertex_index&gt; vi_polygon;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//类模板，创建顶点环绕面的两个索引器</span></span><br><span class="line">	<span class="comment">//vcirc (h, sm)表示从h开始环绕mesh中面的顶点；done(vcirc)用于判断循环是否结束</span></span><br><span class="line">	<span class="function">CGAL::Vertex_around_face_circulator&lt;Polygon_mesh&gt; <span class="title">vcirc</span><span class="params">(mesh_candidate.halfedge(f), mesh_candidate)</span>, <span class="title">done</span><span class="params">(vcirc)</span></span>;</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		Polygon_mesh::Vertex_index vi = *vcirc;<span class="comment">//顶点索引</span></span><br><span class="line">		Kernel::Point_3 p = mesh_candidate.<span class="built_in">point</span>(vi);<span class="comment">//顶点坐标</span></span><br><span class="line">		vi_polygon.<span class="built_in">push_back</span>(vi);</span><br><span class="line">		points_polygon.<span class="built_in">push_back</span>(p);</span><br><span class="line"></span><br><span class="line">		++vcirc;</span><br><span class="line">	&#125; <span class="keyword">while</span> (vcirc != done);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//多边形顶点投影到平面</span></span><br><span class="line">	std::vector&lt;Kernel::Point_2&gt; points_polygon_2;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">const</span> Kernel::Point_3&amp; p : points_polygon)</span><br><span class="line">		points_polygon_<span class="number">2.</span><span class="built_in">push_back</span>(plane_fitting-&gt;<span class="built_in">to_2d</span>(p));</span><br><span class="line"></span><br><span class="line">	<span class="comment">//判断是否有区域点云落在多边形内</span></span><br><span class="line">	<span class="keyword">for</span> (Kernel::Point_2 p : points_region_2)</span><br><span class="line">		<span class="keyword">if</span> (obj_gc.<span class="built_in">isPointInPolygon</span>(p, points_polygon_2))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//遍历该面 f 的顶点，存入</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="type">const</span> Polygon_mesh::Vertex_index&amp; vi : vi_polygon)</span><br><span class="line">			&#123;</span><br><span class="line">				Kernel::Point_3 p = mesh_candidate.<span class="built_in">point</span>(vi);<span class="comment">//顶点坐标</span></span><br><span class="line">				<span class="keyword">if</span> (std::<span class="built_in">find</span>(vi_covered.<span class="built_in">begin</span>(), vi_covered.<span class="built_in">end</span>(), p) == vi_covered.<span class="built_in">end</span>())</span><br><span class="line">					vi_covered.<span class="built_in">push_back</span>(p);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">break</span>;<span class="comment">//该面 f 的顶点数据已存储，无需再遍历 points_region_2</span></span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数GeometryCal::isPointInPolygon()是GPT给的函数，思路参考射线法<sup>[23]</sup>：从当前点引一条射线穿过多边形边界，记录其穿过的次数，交叉数为偶数时点在外侧，奇数时点在内侧。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">GeometryCal::isPointInPolygon</span><span class="params">(<span class="type">const</span> Kernel::Point_2 &amp; point, <span class="type">const</span> std::vector&lt;Kernel::Point_2&gt;&amp; polygon)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">size_t</span> n = polygon.<span class="built_in">size</span>();<span class="comment">//多边形的顶点个数</span></span><br><span class="line">	<span class="type">int</span> count = <span class="number">0</span>;<span class="comment">//交点个数</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//获取边起点和终点</span></span><br><span class="line">		Kernel::Point_2 p1 = polygon[i];</span><br><span class="line">		Kernel::Point_2 p2 = polygon[(i + <span class="number">1</span>) % n];</span><br><span class="line">		<span class="keyword">if</span> (point.<span class="built_in">y</span>() == p<span class="number">1.</span><span class="built_in">y</span>() &amp;&amp; point.<span class="built_in">y</span>() == p<span class="number">2.</span><span class="built_in">y</span>() &amp;&amp; <span class="comment">//点在水平边上</span></span><br><span class="line">			point.<span class="built_in">x</span>() &gt;= std::<span class="built_in">min</span>(p<span class="number">1.</span><span class="built_in">x</span>(), p<span class="number">2.</span><span class="built_in">x</span>()) &amp;&amp; point.<span class="built_in">x</span>() &lt;= std::<span class="built_in">max</span>(p<span class="number">1.</span><span class="built_in">x</span>(), p<span class="number">2.</span><span class="built_in">x</span>()))</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//点在多边形内部</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (point.<span class="built_in">y</span>() &gt; std::<span class="built_in">min</span>(p<span class="number">1.</span><span class="built_in">y</span>(), p<span class="number">2.</span><span class="built_in">y</span>()) &amp;&amp; point.<span class="built_in">y</span>() &lt;= std::<span class="built_in">max</span>(p<span class="number">1.</span><span class="built_in">y</span>(), p<span class="number">2.</span><span class="built_in">y</span>()))</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">isLineIntersect</span>(point, Kernel::<span class="built_in">Point_2</span>(point.<span class="built_in">x</span>() + <span class="number">1e9</span>, point.<span class="built_in">y</span>()), p1, p2))</span><br><span class="line">				count++;<span class="comment">//点的纵坐标在边的纵坐标范围内+水平线与边相交</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> count % <span class="number">2</span> == <span class="number">1</span>; <span class="comment">// 如果交点个数是奇数，点在多边形内部，否则不在</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时vi_covered中存储有若干点，它们可构成聚类点云能投影到的候选面片。仍使用半边环绕器逐个取每个f上的点，当该点在vi_covered中有记录就把这个面存入缓冲面集faces_covered中。这部分写得很冗余，从V1那照抄套用属实难绷。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//3、统计覆盖区域的顶点并保留关联的面，剔除边缘面</span></span><br><span class="line">std::vector&lt;Polygon_mesh::Face_index&gt; faces_covered;<span class="comment">//点云覆盖区域及邻近的面下标</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> Polygon_mesh::Face_index&amp; f : mesh_candidate.<span class="built_in">faces</span>())</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (std::<span class="built_in">find</span>(faces_covered.<span class="built_in">begin</span>(), faces_covered.<span class="built_in">end</span>(), f) != faces_covered.<span class="built_in">end</span>())</span><br><span class="line">		<span class="keyword">continue</span>;<span class="comment">//该面 f 已存入 faces_covered，跳过</span></span><br><span class="line"></span><br><span class="line">	<span class="function">CGAL::Vertex_around_face_circulator&lt;Polygon_mesh&gt; <span class="title">vcirc</span><span class="params">(mesh_candidate.halfedge(f), mesh_candidate)</span>, <span class="title">done</span><span class="params">(vcirc)</span></span>;</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		Polygon_mesh::Vertex_index vi = *vcirc;<span class="comment">//顶点索引</span></span><br><span class="line">		Kernel::Point_3 p = mesh_candidate.<span class="built_in">point</span>(vi);<span class="comment">//顶点坐标</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (std::<span class="built_in">find</span>(vi_covered.<span class="built_in">begin</span>(), vi_covered.<span class="built_in">end</span>(), p) != vi_covered.<span class="built_in">end</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			faces_covered.<span class="built_in">push_back</span>(f);<span class="comment">//faces_covered 中未存在面 f ，将其存入</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		++vcirc;</span><br><span class="line">	&#125; <span class="keyword">while</span> (vcirc != done);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="边缘面查询"><a href="#边缘面查询" class="headerlink" title="边缘面查询"></a>边缘面查询</h3><p>有了缓冲面集faces_covered，那mesh_candidate中的其他候选面便视为边缘面，将它们下标记录为faces_delete后，使用CGAL::Euler::remove_face()将其移除，并在最后调用collect_garbage()对网络做一次修复。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//4、简化面</span></span><br><span class="line">std::vector&lt;Polygon_mesh::Face_index&gt; faces_delete;<span class="comment">//面索引_记录需要删除的面</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> Polygon_mesh::Face_index&amp; f : mesh_candidate.<span class="built_in">faces</span>())</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (std::<span class="built_in">find</span>(faces_covered.<span class="built_in">begin</span>(), faces_covered.<span class="built_in">end</span>(), f) != faces_covered.<span class="built_in">end</span>())</span><br><span class="line">		<span class="keyword">continue</span>;<span class="comment">//该面f属于faces_covered，不用删除</span></span><br><span class="line"></span><br><span class="line">	faces_delete.<span class="built_in">push_back</span>(f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (std::<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; faces_delete.<span class="built_in">size</span>(); ++i)</span><br><span class="line">&#123;</span><br><span class="line">	Polygon_mesh::Face_index f = faces_delete[i];</span><br><span class="line">	Polygon_mesh::Halfedge_index h = mesh_candidate.<span class="built_in">halfedge</span>(f);</span><br><span class="line">	CGAL::Euler::<span class="built_in">remove_face</span>(h, mesh_candidate);<span class="comment">//根据半边索引删除相应面</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mesh_candidate.<span class="built_in">collect_garbage</span>();<span class="comment">//重新组织网络，移除被删除的面</span></span><br></pre></td></tr></table></figure>
<img src="候选面集简化.png" alt="候选面集简化" title="候选面集简化">

<h2 id="计算候选面的置信度"><a href="#计算候选面的置信度" class="headerlink" title="计算候选面的置信度"></a>计算候选面的置信度</h2><p>添加额外的平面属性放下一节详述。那么现在，mesh_candidate中的多边形网络结构如上图所示，原来的多个大块面片经聚类点云切出外轮廓，又经过两两细分变为若干细碎的候选面片。为了从这堆碎片中选出一个最能描述物体几何形状的子集，作者定义了一种称为能量函数的方法来优化这个选择过程，该函数可以由多个能量项构成。<br><img src="能量函数构成.png" alt="能量函数构成" title="能量函数构成"><br>在作者的设计中，能量函数由数据拟合项、模型复杂性项和点覆盖项这三个能量项构成。数据拟合项评估由点簇所拟合平面的置信度，该值根据候选面内的平面点距及点与面的法向量差值来确定，可反映对应点云的平坦度及信噪比。模型复杂性项定义为模型中锐利边缘的比例。二元函数𝑐𝑜𝑟𝑛𝑒𝑟根据相连面属性决定边e是否为锐边，由于面片均以两两相交分割得到，非孤立边与面片的所有拓扑关系如下图所示（图源<sup>[2]</sup>），其中图b、c表示边能将相连面组合为一个更大的多边形，𝑐𝑜𝑟𝑛𝑒𝑟值为1；图d到g中的边可表示为模型边界，𝑐𝑜𝑟𝑛𝑒𝑟值为0。点覆盖项指模型中未覆盖点云的面片占比，它根据点簇在拟合面上的面积与拟合面总面积比值来确定。<br><img src="候选面拓扑关系.png" alt="候选面拓扑关系" title="候选面拓扑关系"><br>能量函数的优化过程属于后一大章的内容先按下不表，先把注意力放在其中的能量项参数上。按公式要求，每个候选面需要增加平面的支撑点数f:num_supporting_points、平面面积f:face_area和覆盖面积f:covered_area这三个新的面片属性。在代码中我是直接调用作者写好的方法，这块的计算对那时的我来说太过耦合，主要是覆盖面积的计算还涉及到Alpha-shape边界提取，这属于另一块CGAL库的算法不太好搬，应该是想了想觉得不会改动里面的计算公式就没把它迁移出来封装。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//6、计算候选面的置信度</span></span><br><span class="line"><span class="comment">//该操作为 mesh_candidate 添加了3个属性映射,用于后续的MIP处理：</span></span><br><span class="line"><span class="comment">//平面的支撑点数	f:num_supporting_points</span></span><br><span class="line"><span class="comment">//平面面积			f:face_area</span></span><br><span class="line"><span class="comment">//覆盖面积			f:covered_area</span></span><br><span class="line">CGAL::internal::Candidate_confidences&lt;Kernel&gt; conf;</span><br><span class="line">conf.<span class="built_in">compute</span>(cloud_plane, mesh_candidate);</span><br></pre></td></tr></table></figure>

<h3 id="计算置信度源码"><a href="#计算置信度源码" class="headerlink" title="计算置信度源码"></a>计算置信度源码</h3><p>候选面属性计算的主流程位于compute_confidences.h的Candidate_confidences<Kernel>::compute()，源码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Kernel&gt;</span><br><span class="line"><span class="type">void</span> Candidate_confidences&lt;Kernel&gt;::<span class="built_in">compute</span>(<span class="type">const</span> Point_set&amp; point_set, Polygon_mesh&amp; mesh) &#123;</span><br><span class="line">	<span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> K = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">	<span class="type">const</span> <span class="keyword">typename</span> Point_set::Point_map&amp; points = point_set.<span class="built_in">point_map</span>();</span><br><span class="line">	FT avg_spacing = <span class="built_in">compute_average_spacing</span>&lt;Concurrency_tag&gt;(points, K);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// The number of supporting points of each face</span></span><br><span class="line">	<span class="keyword">typename</span> Polygon_mesh::<span class="keyword">template</span> Property_map&lt;Face_descriptor, std::<span class="type">size_t</span>&gt; face_num_supporting_points =</span><br><span class="line">		mesh.<span class="keyword">template</span> <span class="built_in">add_property_map</span>&lt;Face_descriptor, std::<span class="type">size_t</span>&gt;(<span class="string">&quot;f:num_supporting_points&quot;</span>).first;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// The area of each face</span></span><br><span class="line">	<span class="keyword">typename</span> Polygon_mesh::<span class="keyword">template</span> Property_map&lt;Face_descriptor, FT&gt; face_areas =</span><br><span class="line">		mesh.<span class="keyword">template</span> <span class="built_in">add_property_map</span>&lt;Face_descriptor, FT&gt;(<span class="string">&quot;f:face_area&quot;</span>).first;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// The point covered area of each face</span></span><br><span class="line">	<span class="keyword">typename</span> Polygon_mesh::<span class="keyword">template</span> Property_map&lt;Face_descriptor, FT&gt; face_covered_areas =</span><br><span class="line">		mesh.<span class="keyword">template</span> <span class="built_in">add_property_map</span>&lt;Face_descriptor, FT&gt;(<span class="string">&quot;f:covered_area&quot;</span>).first;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// The supporting plane of each face</span></span><br><span class="line">	<span class="keyword">typename</span> Polygon_mesh::<span class="keyword">template</span> Property_map&lt;Face_descriptor, <span class="type">const</span> Plane*&gt; face_supporting_planes =</span><br><span class="line">		mesh.<span class="keyword">template</span> <span class="built_in">property_map</span>&lt;Face_descriptor, <span class="type">const</span> Plane*&gt;(<span class="string">&quot;f:supp_plane&quot;</span>).first;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//距离阈值_判断平面是否太小或接近于0。snap_squared_distance_threshold函数会返回一个距离阈值，判断两个点是否足够接近</span></span><br><span class="line">	FT degenerate_face_area_threshold = CGAL::<span class="built_in">snap_squared_distance_threshold</span>&lt;FT&gt;() * CGAL::<span class="built_in">snap_squared_distance_threshold</span>&lt;FT&gt;();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> f : mesh.<span class="built_in">faces</span>()) &#123;</span><br><span class="line">		<span class="type">const</span> Plane* supporting_plane = face_supporting_planes[f];<span class="comment">//获取支撑平面=最适合拟合该面的平面</span></span><br><span class="line">		<span class="comment">// Face area</span></span><br><span class="line">		FT area = <span class="built_in">face_area</span>(f, mesh);<span class="comment">//计算面积</span></span><br><span class="line">		face_areas[f] = area;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (area &gt; degenerate_face_area_threshold) &#123;</span><br><span class="line">			<span class="type">const</span> std::vector&lt;std::<span class="type">size_t</span>&gt;&amp; indices = <span class="built_in">supporting_points</span>(f, mesh, point_set);<span class="comment">//获取每个面上支撑点的索引，即离该面最近点集的点</span></span><br><span class="line">			face_num_supporting_points[f] = indices.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">			std::vector&lt;Point&gt; pts;<span class="comment">//容器_支撑点坐标</span></span><br><span class="line">			<span class="keyword">for</span> (std::<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; indices.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">				std::<span class="type">size_t</span> idx = indices[i];</span><br><span class="line">				<span class="type">const</span> Point&amp; p = points[idx];</span><br><span class="line">				pts.<span class="built_in">push_back</span>(p);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="function">FT <span class="title">covered_area</span><span class="params">(<span class="number">0</span>)</span></span>;<span class="comment">//double值，存储每个面被支撑点覆盖的面积</span></span><br><span class="line">			<span class="function">Alpha_shape_mesh&lt;Kernel&gt; <span class="title">alpha_mesh</span><span class="params">(pts.begin(), pts.end(), *supporting_plane)</span></span>;<span class="comment">//构建α网络，包含所有支撑点且不包含空洞的网络</span></span><br><span class="line">			Polygon_mesh covering_mesh;</span><br><span class="line">			FT radius = avg_spacing * <span class="built_in">FT</span>(<span class="number">5.0</span>);</span><br><span class="line">			<span class="keyword">if</span> (alpha_mesh.<span class="built_in">extract_mesh</span>(radius * radius, covering_mesh)) &#123;</span><br><span class="line">				<span class="comment">// We cannot use the area of the 3D faces, because the alpha shape mesh is</span></span><br><span class="line">				<span class="comment">// not perfectly planar</span></span><br><span class="line">				<span class="comment">//根据半径值 radius 提取表面网络，获取该网络每个顶点的坐标</span></span><br><span class="line">				<span class="type">const</span> <span class="keyword">typename</span> Polygon_mesh::<span class="keyword">template</span> Property_map&lt;Vertex_descriptor, Point&gt;&amp; coords = covering_mesh.<span class="built_in">points</span>();</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">auto</span> face : covering_mesh.<span class="built_in">faces</span>()) &#123;</span><br><span class="line">					<span class="comment">// We have to use the projected version</span></span><br><span class="line">					Polygon plg; <span class="comment">// the projection of the face onto it supporting plane</span></span><br><span class="line">					<span class="function">Halfedge_around_face_circulator&lt;Polygon_mesh&gt; <span class="title">cir</span><span class="params">(covering_mesh.halfedge(face), covering_mesh)</span>, <span class="title">done</span><span class="params">(cir)</span></span>;</span><br><span class="line">					<span class="keyword">do</span> &#123;</span><br><span class="line">						<span class="comment">//通过调取多边形半边，获取顶点的二维坐标，将之加入到多边形中</span></span><br><span class="line">						Halfedge_descriptor hd = *cir;</span><br><span class="line">						Vertex_descriptor vd = covering_mesh.<span class="built_in">target</span>(hd);</span><br><span class="line">						<span class="type">const</span> Point&amp; p = coords[vd];</span><br><span class="line">						<span class="type">const</span> Point2&amp; q = supporting_plane-&gt;<span class="built_in">to_2d</span>(p);</span><br><span class="line">						plg.<span class="built_in">push_back</span>(q);</span><br><span class="line">						++cir;</span><br><span class="line">					&#125; <span class="keyword">while</span> (cir != done);</span><br><span class="line">					covered_area += std::<span class="built_in">abs</span>(plg.<span class="built_in">area</span>());<span class="comment">//计算多边形面积，累加到覆盖面积中，使用绝对值避免负数情况</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			face_covered_areas[f] = covered_area;<span class="comment">//每个面的覆盖面积存储到属性映射face_covered_areas</span></span><br><span class="line">			<span class="keyword">if</span> (covered_area &gt; area)</span><br><span class="line">				face_covered_areas[f] = area;<span class="comment">//覆盖面积大于原始面积，存在某些超出范围的支撑点，将面积设为原始面积</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123; <span class="comment">// For tiny faces, we can simple assign zero supporting points</span></span><br><span class="line">			face_num_supporting_points[f] = <span class="number">0</span>;<span class="comment">//平面面积小于等于阈值，将每个面上支撑点的数量设置为零</span></span><br><span class="line">			face_covered_areas[f] = <span class="built_in">FT</span>(<span class="number">0.0</span>);<span class="comment">//将每个面的覆盖面积设置为零</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="添加额外的平面属性"><a href="#添加额外的平面属性" class="headerlink" title="添加额外的平面属性"></a>添加额外的平面属性</h2><p>这一小节是自己添加的内容，给候选面多增加一个离顶面距离的属性，试图为能量函数多加一个新能量项做准备。思路很简单，取每个面片的中心点，计算点到包围盒顶面的距离，再将该距离除以包围盒上下面的距离来归一化。实现函数在HypothesisPlaneProcess::AddMeshProperty()。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">HypothesisPlaneProcess::AddMeshProperty</span><span class="params">(Polygon_mesh &amp; mesh_candidate)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">typename</span> Polygon_mesh::<span class="keyword">template</span> Property_map&lt;Polygon_mesh::Face_index, <span class="type">double</span>&gt; face_roof =</span><br><span class="line">		mesh_candidate.<span class="keyword">template</span> <span class="built_in">add_property_map</span>&lt;Polygon_mesh::Face_index, <span class="type">double</span>&gt;(<span class="string">&quot;f:dist_boxTop&quot;</span>).first;<span class="comment">//属性映射_面片属顶面</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//候选面顶点集</span></span><br><span class="line">	<span class="function">std::vector&lt;Kernel::Point_3&gt; <span class="title">vertices</span><span class="params">(mesh_candidate.number_of_vertices())</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; mesh_candidate.<span class="built_in">vertices</span>().<span class="built_in">size</span>(); ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">const</span> Polygon_mesh::Vertex_index v = mesh_candidate.<span class="built_in">vertices</span>().first[i];</span><br><span class="line">		vertices[i] = mesh_candidate.<span class="built_in">points</span>()[v];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//计算包围盒</span></span><br><span class="line">	<span class="type">const</span> Kernel::Iso_cuboid_3&amp; box = CGAL::<span class="built_in">bounding_box</span>(vertices.<span class="built_in">begin</span>(), vertices.<span class="built_in">end</span>());<span class="comment">//计算 vertices 点集的最小包围盒</span></span><br><span class="line">	FT dx = box.<span class="built_in">xmax</span>() - box.<span class="built_in">xmin</span>();<span class="comment">//包围盒xyz方向上的长度</span></span><br><span class="line">	FT dy = box.<span class="built_in">ymax</span>() - box.<span class="built_in">ymin</span>();</span><br><span class="line">	FT dz = box.<span class="built_in">zmax</span>() - box.<span class="built_in">zmin</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//计算包围盒顶面</span></span><br><span class="line">	std::vector&lt;Kernel::Point_3&gt; point_boxTop;<span class="comment">//包围盒顶面点</span></span><br><span class="line">	point_boxTop.<span class="built_in">push_back</span>(Kernel::<span class="built_in">Point_3</span>(box.<span class="built_in">xmin</span>(), box.<span class="built_in">ymin</span>(), box.<span class="built_in">zmax</span>()));</span><br><span class="line">	point_boxTop.<span class="built_in">push_back</span>(Kernel::<span class="built_in">Point_3</span>(box.<span class="built_in">xmax</span>(), box.<span class="built_in">ymin</span>(), box.<span class="built_in">zmax</span>()));</span><br><span class="line">	point_boxTop.<span class="built_in">push_back</span>(Kernel::<span class="built_in">Point_3</span>(box.<span class="built_in">xmax</span>(), box.<span class="built_in">ymax</span>(), box.<span class="built_in">zmax</span>()));</span><br><span class="line">	point_boxTop.<span class="built_in">push_back</span>(Kernel::<span class="built_in">Point_3</span>(box.<span class="built_in">xmin</span>(), box.<span class="built_in">ymax</span>(), box.<span class="built_in">zmax</span>()));</span><br><span class="line">	Kernel::Plane_3 plane_boxTop;</span><br><span class="line">	CGAL::<span class="built_in">linear_least_squares_fitting_3</span>(point_boxTop.<span class="built_in">begin</span>(), point_boxTop.<span class="built_in">end</span>(), plane_boxTop, CGAL::<span class="built_in">Dimension_tag</span>&lt;<span class="number">0</span>&gt;());</span><br><span class="line"></span><br><span class="line">	<span class="comment">//遍历候选面集的每个面片</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">const</span> Polygon_mesh::Face_index&amp; f : mesh_candidate.<span class="built_in">faces</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">double</span> x_center = <span class="number">0.0f</span>, y_center = <span class="number">0.0f</span>, z_center = <span class="number">0.0f</span>;</span><br><span class="line">		<span class="type">int</span> num_p = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//累计该面上的点坐标</span></span><br><span class="line">		<span class="function">CGAL::Vertex_around_face_circulator&lt;Polygon_mesh&gt; <span class="title">vcirc</span><span class="params">(mesh_candidate.halfedge(f), mesh_candidate)</span>, <span class="title">done</span><span class="params">(vcirc)</span></span>;</span><br><span class="line">		<span class="keyword">do</span> &#123;</span><br><span class="line">			Polygon_mesh::Vertex_index vi = *vcirc;<span class="comment">//顶点索引</span></span><br><span class="line">			Kernel::Point_3 p = mesh_candidate.<span class="built_in">point</span>(vi);<span class="comment">//顶点坐标</span></span><br><span class="line"></span><br><span class="line">			x_center += p.<span class="built_in">x</span>();</span><br><span class="line">			y_center += p.<span class="built_in">y</span>();</span><br><span class="line">			z_center += p.<span class="built_in">z</span>();</span><br><span class="line">			++num_p;</span><br><span class="line"></span><br><span class="line">			++vcirc;</span><br><span class="line">		&#125; <span class="keyword">while</span> (vcirc != done);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//面片中心点</span></span><br><span class="line">		<span class="function">Kernel::Point_3 <span class="title">p_center</span><span class="params">(x_center / num_p, y_center / num_p, z_center / num_p)</span></span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//点到平面的距离 / 包围盒高度</span></span><br><span class="line">		<span class="comment">//除以包围盒高度是想归一化处理，让值处于[0,1]</span></span><br><span class="line">		<span class="type">double</span> dist_p2plane = std::<span class="built_in">sqrt</span>(CGAL::<span class="built_in">squared_distance</span>(p_center, plane_boxTop)) /(box.<span class="built_in">zmax</span>() - box.<span class="built_in">zmin</span>());</span><br><span class="line"></span><br><span class="line">		<span class="comment">//属性映射赋值</span></span><br><span class="line">		face_roof[f] = dist_p2plane;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该属性目的是想提高“屋顶”候选面片在能量函数中的权重，当该项属性越接近0则表明面片越靠近顶部，若最终模型选取这类面的数量越多，那可以期望其顶面细节越丰富。不过单靠这个值是不可靠的，应该还需要加某种约束条件。从以前的测试结果来看并不理性，仍把代码放进来，仅为提供一个添加平面属性的参考。<br>至此，上一大节的区域朝向面片已被处理为候选面集。下一大节解析能量函数，看他如何从杂乱无章的候选面集挑选出最终模型。<br><img src="区域朝向面片2候选面集.png" alt="区域朝向面片2候选面集" title="区域朝向面片2候选面集"></p>
<h2 id="参考文献-引用"><a href="#参考文献-引用" class="headerlink" title="参考文献&amp;引用"></a>参考文献&amp;引用</h2><p><span>[1] <a target="_blank" rel="noopener" href="https://3d.bk.tudelft.nl/liangliang/">https://3d.bk.tudelft.nl/liangliang/</a></span><br><span>[2] <a target="_blank" rel="noopener" href="https://3d.bk.tudelft.nl/liangliang/publications/2017/polyfit/polyfit.html">https://3d.bk.tudelft.nl/liangliang/publications/2017/polyfit/polyfit.html</a></span><br><span>[3] <a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=_0brfDFkIkc">https://www.youtube.com/watch?v=_0brfDFkIkc</a></span><br><span>[4] Linfu X ,Han H ,Qing Z , et al. Combined Rule-Based and Hypothesis-Based Method for Building Model Reconstruction from Photogrammetric Point Clouds [J]. Remote Sensing, 2021, 13 (6): 1107-1107.</span><br><span> [5] Nan L , Wonka P .PolyFit: Polygonal Surface Reconstruction from Point Clouds[C]&#x2F;&#x2F;International Conference on Computer Vision.IEEE, 2017.</span><br>[6] <a target="_blank" rel="noopener" href="https://github.com/Kitware/CMake/releases/download/v3.29.3/cmake-3.29.3-windows-x86_64.zip">https://github.com/Kitware/CMake/releases/download/v3.29.3/cmake-3.29.3-windows-x86_64.zip</a><br>[7] <a target="_blank" rel="noopener" href="https://boostorg.jfrog.io/artifactory/main/release/1.85.0/source/boost_1_85_0.7z">https://boostorg.jfrog.io/artifactory/main/release/1.85.0/source/boost_1_85_0.7z</a><br>[8] <a target="_blank" rel="noopener" href="https://github.com/CGAL/cgal/releases/download/v5.6.1/CGAL-5.6.1.zip">https://github.com/CGAL/cgal/releases/download/v5.6.1/CGAL-5.6.1.zip</a><br>[9] <a target="_blank" rel="noopener" href="https://gitlab.com/libeigen/eigen/-/archive/3.4.0/eigen-3.4.0.zip">https://gitlab.com/libeigen/eigen/-/archive/3.4.0/eigen-3.4.0.zip</a><br>[10] <a target="_blank" rel="noopener" href="https://scipopt.org/download.php?fname=SCIPOptSuite-9.0.0-win64-VS15.exe">https://scipopt.org/download.php?fname=SCIPOptSuite-9.0.0-win64-VS15.exe</a><br>[11] <a target="_blank" rel="noopener" href="https://zenodo.org/records/4390295#.Y0eIodJBxuV">https://zenodo.org/records/4390295#.Y0eIodJBxuV</a><br>[12] <a target="_blank" rel="noopener" href="https://www.zhihu.com/question/277599635/answer/2149719454">https://www.zhihu.com/question/277599635/answer/2149719454</a><br>[13] <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/668272208">https://zhuanlan.zhihu.com/p/668272208</a><br>[14] <a target="_blank" rel="noopener" href="https://doc.cgal.org/latest/Polygonal_surface_reconstruction/index.html#Chapter_PolygonalSurfaceReconstruction">https://doc.cgal.org/latest/Polygonal_surface_reconstruction/index.html#Chapter_PolygonalSurfaceReconstruction</a><br>[15] <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/90858099">https://zhuanlan.zhihu.com/p/90858099</a><br>[16] <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/668272208">https://zhuanlan.zhihu.com/p/668272208</a><br>[17] <a target="_blank" rel="noopener" href="https://doc.cgal.org/latest/HalfedgeDS/index.html">https://doc.cgal.org/latest/HalfedgeDS/index.html</a><br>[18] <a target="_blank" rel="noopener" href="https://segmentfault.com/q/1010000043819426">https://segmentfault.com/q/1010000043819426</a><br>[19] <a target="_blank" rel="noopener" href="https://doc.cgal.org/latest/BGL/group__PkgBGLEulerOperations.html#gaa386d0cdef3b5d6ef43d6b503392dbcd">https://doc.cgal.org/latest/BGL/group__PkgBGLEulerOperations.html#gaa386d0cdef3b5d6ef43d6b503392dbcd</a><br><font color=#CD5C5C>[20] <a target="_blank" rel="noopener" href="https://doc.cgal.org/latest/Shape_regularization/index.html">https://doc.cgal.org/latest/Shape_regularization/index.html</a><br>[21] <a target="_blank" rel="noopener" href="https://doi.org/10.3390/rs13061107">https://doi.org/10.3390/rs13061107</a><br>[22] <a target="_blank" rel="noopener" href="https://doi.org/10.1016/j.isprsjprs.2022.09.017">https://doi.org/10.1016/j.isprsjprs.2022.09.017</a><br>[23] <a target="_blank" rel="noopener" href="https://blog.csdn.net/u013279723/article/details/106265948">https://blog.csdn.net/u013279723/article/details/106265948</a><br></font></p>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>Sleeping-Ahead
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://example.com/2025/01/21/PolyFit06/" title="点云三维重建 PolyFit算法解析与改进（六）">http://example.com/2025/01/21/PolyFit06/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/C/" rel="tag"><i class="fa fa-tag"></i> C++</a>
              <a href="/tags/CGAL/" rel="tag"><i class="fa fa-tag"></i> CGAL</a>
              <a href="/tags/PolyFit/" rel="tag"><i class="fa fa-tag"></i> PolyFit</a>
              <a href="/tags/%E9%9D%A2%E7%89%87%E7%BB%93%E6%9E%84%E5%A4%84%E7%90%86/" rel="tag"><i class="fa fa-tag"></i> 面片结构处理</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2025/01/11/SFM01/" rel="prev" title="运动结构恢复（一） SFM理论记录">
      <i class="fa fa-chevron-left"></i> 运动结构恢复（一） SFM理论记录
    </a></div>
      <div class="post-nav-item">
    <a href="/2025/02/19/PolyFit07/" rel="next" title="点云三维重建 PolyFit算法解析与改进（七）">
      点云三维重建 PolyFit算法解析与改进（七） <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%80%99%E9%80%89%E5%B9%B3%E9%9D%A2%E7%9B%B8%E4%BA%A4%E7%BB%86%E5%88%86"><span class="nav-number">1.</span> <span class="nav-text">候选平面相交细分</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E4%B8%89%E9%87%8D%E4%BA%A4%E7%82%B9"><span class="nav-number">1.1.</span> <span class="nav-text">计算三重交点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A1%AE%E5%AE%9A%E7%9B%B8%E4%BA%A4%E9%9D%A2%EF%BC%88%E5%8F%8A%E5%85%B6%E4%BA%A4%E7%82%B9%EF%BC%89"><span class="nav-number">1.2.</span> <span class="nav-text">确定相交面（及其交点）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%B3%E9%9D%A2%E5%88%86%E5%89%B2"><span class="nav-number">1.3.</span> <span class="nav-text">平面分割</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%80%99%E9%80%89%E9%9D%A2%E9%9B%86%E7%AE%80%E5%8C%96"><span class="nav-number">2.</span> <span class="nav-text">候选面集简化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8C%BA%E5%9F%9F%E5%BD%92%E7%B1%BB"><span class="nav-number">2.1.</span> <span class="nav-text">区域归类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%87%E8%AE%B0%E7%BC%93%E5%86%B2%E5%8C%BA%E9%9D%A2%E7%89%87"><span class="nav-number">2.2.</span> <span class="nav-text">标记缓冲区面片</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BE%B9%E7%BC%98%E9%9D%A2%E6%9F%A5%E8%AF%A2"><span class="nav-number">2.3.</span> <span class="nav-text">边缘面查询</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E5%80%99%E9%80%89%E9%9D%A2%E7%9A%84%E7%BD%AE%E4%BF%A1%E5%BA%A6"><span class="nav-number">3.</span> <span class="nav-text">计算候选面的置信度</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E7%BD%AE%E4%BF%A1%E5%BA%A6%E6%BA%90%E7%A0%81"><span class="nav-number">3.1.</span> <span class="nav-text">计算置信度源码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B7%BB%E5%8A%A0%E9%A2%9D%E5%A4%96%E7%9A%84%E5%B9%B3%E9%9D%A2%E5%B1%9E%E6%80%A7"><span class="nav-number">4.</span> <span class="nav-text">添加额外的平面属性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE-%E5%BC%95%E7%94%A8"><span class="nav-number">5.</span> <span class="nav-text">参考文献&amp;引用</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Sleeping-Ahead"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Sleeping-Ahead</p>
  <div class="site-description" itemprop="description">主要用途是技术/算法的记录博客哒！<br>偶尔摘抄点杂七杂八的随想~~<br>嘻嘻ԅ(¯﹃¯ԅ)</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">17</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">27</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Sleeping-ahead" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Sleeping-ahead" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="https://space.bilibili.com/179235151" title="bilibili → https:&#x2F;&#x2F;space.bilibili.com&#x2F;179235151" rel="noopener" target="_blank"><i class="iconfont icon-bilibili fa-fw"></i></a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Sleeping-Ahead</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">126k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">3:50</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

<!-- 网站运行时间的设置 -->
<span id="timeDate">载入天数...</span>
<span id="times">载入时分秒...</span>
<script>
    var now = new Date();
    function createtime() {
        var grt= new Date("03/01/2023 10:00:00"); //此处修改你的建站时间或者网站上线时间
        now.setTime(now.getTime()+250);
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;}
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;}
        document.getElementById("timeDate").innerHTML = "本站已安全运行 "+dnum+" 天 ";
        document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒.";
    }
setInterval("createtime()",250);
</script>
        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
